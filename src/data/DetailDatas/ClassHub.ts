import MainImg from "assets/img/ClassHub/Mainpage2.jpg";
import Commupage from "assets/img/ClassHub/CommunityPage.jpg";
import CommuDetail from "assets/img/ClassHub/CommuDetail.jpg";
import LecturePage from "assets/img/ClassHub/LecturePage2.jpg";
import PaymentedPage from "assets/img/ClassHub/PaymentedPage.jpg";
import MyPageDashBoard from "assets/img/ClassHub/MypageDashBoard.jpg";
export const ClassHubData = {
  id: "Class",
  title: "ClassHub",
  mainImage: MainImg,
  colorConcept: "#70AEF9",
  personnel: [1, 3, 4],
  date: "2024.05.01~ 2024.06.18",
  Contribution: "35%",
  role: "프론트엔드 담당",
  skills: [
    {
      name: "React",
      description: [
        "React는 컴포넌트 기반으로, Virtual DOM을 활용해 웹 애플리케이션의 성능을 최적화 합니다. 컴포넌트 재사용성을 높입니다.",
      ],
    },
    {
      name: "React-Query",
      description: [
        "React Query는 React 애플리케이션에서 데이터 가져오기, 관리 및 캐싱을 사용하기 쉽게 해주는 라이브러리입니다. \n 서버에서 데이터를 비동기적으로 가져오고 `Mutation`을 사용하여 낙관적 업데이트를 통해 사용자 경험을 개선합니다.",
        "API 요청을 처리하고 결과를 캐싱하여 성능을 최적화할 수 있습니다.",
      ],
    },
    {
      name: "Typescript",
      description: [
        "TypeScript는 JavaScript의 슈퍼셋 언어로, 정적 타입을 지원하여 코드를 작성할 때 타입을 명시함으로써 오류를 사전에 확인할 수 있어 개발 과정의 `안전성`을 높여줍니다",
      ],
    },
    {
      name: "tailwindCSS",
      description: [
        "TailwindCSS는 클래스 기반 스타일링을 통해 `일관된 디자인을 빠르게 구현`할 수 있는 CSS 프레임워크입니다.",
        "특히, 반응형 웹 구현 가속화하기 좋으며 개발자의 `피로도를 줄이는 장점`이 있습니다",
      ],
    },
    {
      name: "styled-components",
      description: [
        "Styled Components는 JavaScript 코드 내에서 CSS를 작성할 수 있게 해주는 CSS-in-JS 라이브러리입니다. ",
        "컴포넌트와 스타일을 함께 정의하여 스타일을 관리하고 재사용할 수 있으며, `props`를 전달하여 조건부로 스타일을 다르게 적용할 수 있습니다.",
      ],
    },
  ],
  summary: `**클래스허브** 는 언제 어디서나 접근 가능한 온라인 학습 플랫폼으로 \n\n  다양한 프로그래밍 주제와 전문가 강의를 통해 학생들에게 편리하고 효율적인 학습 경험을 제공합니다.`,
  background:
    "개발자로 성장하는 과정에서 독학으로 여러 학습 시스템을 활용한 경험이 많은 저는 인프런이나 유데미 등 학습 플랫폼에서 제공되는 영상 이어보기, 학습 현황 추적 기능을 직접 구현해 보고 또한 학습자들과 소통할 수있는 기능과 특히 독학자를 위한 스터디 모집 기능을 구현해보면\n 좋을 것 같다는 생각이 들어서, 효율적인 학습 환경을 구현해보고자 프로젝트를 기획하게 되었습니다. ",
  mainFuntion: [
    "커뮤니티의 질문답변 및 스터디 모집 글 등록, 댓글 등록",
    "강의 영상 이어듣기",
    "강의 장바구니 관리 기능",
    "PortOne을 활용한 결제 및 결제내역 조회 기능",
    "사용자의 프로필관리 및 권한 설정",
  ],
  myActivities: [
    {
      title:
        "로그인 JWT토큰을 쿠키로 관리, 유저 정보를 Context API를 통한 전역적 활용",
      description: [
        "기존 클라이언트 측에서 Google API 를 사용하여 구글 로그인과 localStorage를 활용한 자동 로그인 기능을 구현",
        "사용자의 고유한 정보 일부분을 localStorage를 통해 자동 로그인을 구현하다 보니 데이터의 위·변조와 같은 보안에 취약하다는 문제점을 인식",
        "백엔드 팀과 조율을 통해 `스프링 시큐리티를 도입`하여 보안성을 강화하기로 결정",
        "로그인 과정에서 사용자는 백엔드에서 제공한 URL을 통해 로그인 전용 페이지로 이동하여 로그인을 진행하며, 로그인 성공 시 백엔드에서 JWT 토큰을 생성하여 브라우저의 쿠키에 저장 이후 메인 페이지로 리다이렉션",
        "성공적으로 쿠키가 발급 된 경우, 쿠키가 저장된 `JWT 토큰`과  useEffect 훅을 사용하여 특정 기능에서 필요한 사용자 정보 일부를 요청",
        "가져온 정보는 `Context API` 를 활용하여 애플리케이션 전역 상태로 관리",
      ],
    },
    {
      title: "강의 업로드 페이지 구현",
      description: [
        "강의 제목, 가격, 설명 등 일반적인 정보들은 useState를 통해 원시 타입으로 관리",
        "영상들은 섹션별로 저장하기위해 객체 배열로 구성\n각 섹션은 객체로 생성하고 영상 부분은 배열로 설정  ( 한 섹션당 영상은 최대 3개 까지 )",
        "영상 추가 시, 상태를 확인할 수 있도록 미리보기 제공",
        "강의 데이터들은 파일 데이터가 포함되어 있기 때문에 FormData 객체로 전달",
        "업로드 시 Content-Type 속성의 경우, 강의의 일반적인 정보들은 JSON 형식으로 전달하고, \n영상과 이미지 같은 경우 multipart/form-data 형식으로 전달하도록 설정",
      ],
    },
    {
      title: "PortOne을 활용하여 강의 결제 및 결제내역 조회 구현",
      description: [
        "강의 바로 결제 및 장바구니 결제 시, 사전 결제를 먼저 진행한 후 본 결제를 진행",
        "사전 결제의 경우 강의 정보, 금액 정보를 DB로 전달하는 API를 호출하여 결제 정보를 저장",
        "본 결제를 진행하기 전, 사전 결제일과 동일한 결제일 시에만 결제가 진행",
        "결제가 성공적으로 이루어지면 반환 된 주문 번호를 참조하여 결제 내역을 추가 조회하고, \n사용자 화면에 결제가 성공적으로 완료되었음을 알리는 결제 내역을 출력",
        "결제 내역은 주문 번호, 구매자 명, 이메일, 연락처, 결제 여부 및 수단, 카드 번호를 제공",
      ],
    },
    {
      title: "localStorage를 사용하여 영상 이어듣기 구현",
      description: [
        "이어듣기를 구현하기 위해 사용자가 종료하더라도, 데이터를 지속적으로 유지할 필요가 있기 때문에 클라이언트 측에서 영구적으로 데이터를 저장할 수 있는 방법인 `localStorage`를 선택 ",
        "React-Player 라이브러리를 활용하여, 특정 상황에 맞춰 영상 데이터를 업데이트하도록 설정",
        "영상이 준비되면, 기존 localStorage에서 강의 ID를 Key로 사용하여 저장된 데이터를 확인 후 데이터가 존재하는 경우, 영상 재생 시점을 저장된 데이터에 따라 이동",
        "영상이 멈추면, 현재 시점을 localStorage에 강의 ID를 Key로 사용하여 업데이트",
        "사용자가 시청 중 강제 종료되거나 예기치 않은 상황에 대비하여, 일정 시간마다 영상의 현재 시점을 localStorage에 자동으로 업데이트",
      ],
    },
  ],
  troubleShooting: [
    {
      title: "커뮤니티 댓글목록 사용자 경험 향상",
      trouble:
        "**[문제점]** \n커뮤니티 게시글에 댓글을 작성 시 새로고침 시에만 댓글을 확인할 수 있으며, 새로고침 시 화면이 깜빡거리며 사용자 경험이 저하 됨",
      Resolution:
        "**[해결방안]** \nuseState를 통해 UI를 업데이트하고, 후속 작업을 통해 서버에 업데이트가 가능하지만, React-Query의 서버 응답에 따른 처리와 데이터 동기화 기능이 동시에 가능한 점을 이용",
      result: [
        "**[결과]**\n1.&nbsp;Mutation을 통해 댓글을 작성하게 되면 mutate를 실행 시킨 후, onMutate를 통해 기존 쿼리를 취소하는 `queryClient.cancelQueries` 실행하여, 현재 실행 중인 쿼리를 중단 시키므로 서버 상태와 클라이언트 상태의 충돌을 방지 합니다.",
        "2.&nbsp;업데이트 중 오류가 발생할 경우를 대비하여 `queryClient.getQueryData` 사용하여 기존 데이터를 백업해 둡니다.",
        "3.&nbsp;`queryClient.setQueryData` 사용해 서버에 업데이트 되기 전 클라이언트에서 바로 데이터를 업데이트 하여 실시간으로 데이터가 업데이트된 것 처럼보이도록 `Optimistic Update`를 적용하여 UI를 업데이트 합니다.",
        "4.&nbsp;서버 응답이 반환되면 `onSettled` 를 호출하여, 해당 쿼리를 무효화하도록 설정하고 서버 데이터와 동기화 시켜 UI를 최신 상태로 유지합니다.",
        "5.&nbsp;에러가 발생할 때를 대비하여 `onError` 를 통해, onMutate에서 저장한 백업 데이터를 사용하여 클라이언트 상태를 원래대로 복원할 수 있습니다.",
      ],
      myThink:
        "**[느낀점]** \n댓글 작성 시 새로고침 없이, 댓글 목록 실시간으로 업데이트 되어, 작성한 댓글이 즉각 반영되는 것을 경험할 수 있었고, 깜빡임도 사라져 사용자 경험을 개선 시킬 수 있었습니다.\n또한, Mutation 를 사용함으로써 서버 응답에 따른 처리를 동시에 진행할 수 있었기 때문에 개발 과정에서 효율성을 향상 시킬 수 있었습니다.",
    },
    {
      title: "스프링 시큐리티 추가 및 배포 후 발생한 CORS 문제 해결",
      trouble:
        "**[문제점]**\n 기존 클라이언트 측에서 구현한 자동 로그인 기능이 데이터의 위· 변조 및 보안에 취약하다는 점을 알게 되며, 이를 개선하기 위해 스프링 시큐리티를 통한 JWT 토큰을 사용하여 배포 작업을 마쳤습니다. 그러나 이전 발생한적이 없던 CORS 에러가 발생하게 되었습니다. \n\n `Access-Control-Allow-Origin` 에 프론트 도메인이 추가된 상태임에도 에러가 발생",
      serach:
        "**[중간 소통 및 해결방안]**\n 팀원들과 각자의 개발 환경을 공유하고 현재 문제 상황에 대해 소통하는 과정에서, 백엔드 팀원들이 스프링 시큐리티에 대한 숙련도가 부족하다는 점을 알게 되었습니다. 이로 인해 문제 발생 지점을 찾는 데 많은 시간이 소요될 것이라고 전달 받았습니다. \n\n 프론트엔드 팀원이 1명인 상황에서 많은 작업량을 처리해야 했기에 문제 해결을 기다리기엔 시간이 부족하였고, 클라이언트 측에서 해결할 방법을 찾던 중 http-proxy-middleware 라이브러리를 발견했습니다. \n\n`http-proxy-middleware` : 프록시 서버를 쉽게 설정할 수있는 미들웨어클라이언트 요청을 다른 서버로 중계하여, CORS문제를 우회할 수 있다.\n`proxy` : 클라이언트와 서버 사이에 중계 서버를 두어, 클라이언트 요청을 대신 처리하거나 응답하는 역할을 한다. ",
      result: [
        "**[결과]**\n `http-proxy-middleware` 라이브러리를 사용하여 배포된 사이트의 URL로 호출하도록 설정하여 일시적으로 CORS에러를 해결한 후 작업을 진행하였습니다.",
      ],
      myThink:
        "**[느낀점]**\n API 의존도가 높은 프로젝트에서 CORS 오류 발생 시 아무 작업을 할 수 없다는 점을 실감하였습니다. 이런 상황을 대비하여 `Mock Service Worker` 의 필요성을 느꼈고, 미리 Mock 데이터를 활용하는 방법에 대해 학습해야겠다고 생각하게 되었습니다.",
    },
    {
      title: "강의 썸네일 및 영상 데이터 처리 이슈 해결 시도와 차선책 구현",
      trouble:
        "**[문제점]**\n 강의 데이터 호출 시, 썸네일 및 영상 데이터가 URL 형태로 제공되었으나, 해당 URL을 참조할 시 데이터가 출력되지 않았습니다. 강의 컴포넌트에서 썸네일이 로드되지 않고, 영상 시청 페이지에서도 영상이 출력되지 않았습니다.",
      tryProp: {
        text: "[문제 해결을 위해 시도한 방법]",
        trylist: [
          "데이터를 호출하였을 때 전달 받은 데이터 URL을 브라우저 주소창에 입력하여 확인해보았으나 커뮤니티 이미지 데이터는 잘 가져오나, 강의 썸네일 이미지 데이터는 가져오지 못했다.",
          "강의 썸네일을 가져오는 로직을 커뮤니티의 이미지를 불러오는 방식으로 변경해보았지만 데이터를 가져올 수 없었다.",
          "영상 데이터의 경우 react player가 아닌 일반 html 태그인 video 태그도 활용해보았지만출력이 되지 않았다.",
          "화면 공유를 통해 백엔드 팀과 실시간으로 강의 등록 시 데이터가 제대로 전달되는지 확인하는 과정에서 데이터는 제대로 전달되는 것으로 확인되었으나, 백엔드에서 `Ubuntu`에 저장하는 과정에서 문제가 발생하는 것으로 확인되었다.",
        ],
      },
      Resolution:
        "**[해결 실패]**\n 백엔드 팀과 계속 논의하였으나, 강의 썸네일은 커뮤니티 이미지와 동일한 방식이기 때문에, 저장되고 불러와야 했으나 데이터가 출력되지 않았습니다. \n또한, 영상 시청 페이지에서 이어듣기 기능을 구현하기 위해 영상 데이터가 필수였으나, 데이터를 가져올 수 없어 실시간 데이터 동기화 및 이어듣기 기능 구현이 불가능했습니다.",
      tryResult: {
        text: "[결과]",
        trylist: [
          "`Ubuntu` 저장과정에서 발생하는 문제라 프론트 입장에서 더 이상 도움을 줄 수 있는 방법이 없었다.",
          "차선책으로 프론트엔드 로컬 환경에서 임의의 영상 데이터를 삽입하여, localStorage를 통해 영상 준비시점, 영상 중단시점, 일정시간마다 데이터를 업데이트 하도록 구현하였다.",
        ],
      },
      myThink:
        "**[느낀점]**\n 영상 데이터를 실시간으로 주고받는 기능을 구현하지 못해 아쉬움이 있었으나, localStorage를 활용해 이어듣기 기능을 구현할 수 있었던 점에 만족했습니다.\n또한, `Ubuntu 저장 방식`에 대해 이해하고 있었다면 문제를 해결할 수 있었을 것이라는 생각을 하게 되었고, 추후에 기회가 된다면 관련 지식을 더 쌓아야겠다고 생각하게 되었습니다.",
    },
  ],
  experience: [
    {
      title: "로그인 보안 강화 및 전역 상태 관리 이해",
      text: [
        "localStorage를 활용한 기존 자동 로그인 기능의 보안 취약성을 인지하고, 팀원들과 협력하여 `스프링 시큐리티와 JWT 토큰을 도입`하여 보안성을 강화했습니다",
        "JWT 토큰을 쿠키에 저장하고, `Context API`를 활용해 유저 정보를 전역 상태로 관리함으로써 보안과 사용자 경험을 동시에 개선했습니다.",
        "Context API를 학습하는 과정에서 상태가 변경될 시, 모든 컴포넌트가 다시 렌더링되는 단점을 알게되면서, 상태관리 라이브러리를 사용하는 이유에 대해 알 수 있었습니다.",
        "Context API는 자주 변경되지 않는 상태를 관리할 때만 사용하거나, \n독립적인 상태를 가지며 성능 최적화와 상태 분리 등 많은 기능을 제공하는 상태 관리 라이브러리를 이용하는 것이 좋겠다는 생각을 하게되었습니다.",
      ],
    },
    {
      title: "불필요한 API 호출 최소화 및 사용자 경험 향상",
      text: [
        "React-Query의 Mutation의 `Optimistic Update`를 활용하여 커뮤니티 댓글 목록의 실시간 업데이트를 구현함으로써, 새로고침 없이도 즉각적으로 반영되는 UI를 제공하였습니다. ",
        "화면 깜빡임 없이 부드럽고 빠른 사용자 경험을 제공할 수 있었으며, 서버와 클라이언트의 데이터 동기화를 통해 최신 데이터를 제공할 수 있었습니다.",
        "React-Query를 통해 브라우저 메모리에 데이터를 저장하는 개념인 캐시를 통해, 데이터를 재사용함으로써 불필요한 API를 최소화할 수 있었습니다.",
      ],
    },
    {
      title: "팀 협업의 중요성 인식",
      text: [
        "CORS 문제 해결하는 과정에서 팀워크의 중요성을 깨달았습니다. ",
        "스프링 시큐리티를 통한 JWT 토큰 도입 후 CORS 문제를 해결하는 과정에서, 백엔드 팀과의 협업이 필수적이었습니다. ",
        "특히 백엔드 팀이 스프링 시큐리티에 익숙하지 않아 문제 해결에 어려움을 겪었을 때, 팀원들과의 함께 문제 원인 및 임시적인 해결 방안을 찾아내며 프론트엔드에서 가능한 해결책`http-proxy-middleware`을 제시해주며 적용한 경험이 팀 협업의 중요성을 깨닫게 해주었습니다.",
      ],
    },
    {
      title: "프론트엔드와 백엔드 간의 이해 필요성",
      text: [
        "강의 데이터 처리 문제에서 `Ubuntu 환경과 데이터 저장 방식`에 대한 이해 부족으로 문제 해결에  어려움을 겪으며, 프론트엔드 개발자도 백엔드 기술과 환경에 대해 어느 정도 이해가 필요하다는 점을 깨달았습니다. ",
      ],
    },
  ],
  ProjectIMG: [
    { img: MainImg, imgDescrip: "메인 페이지" },
    { img: Commupage, imgDescrip: "커뮤니티 페이지" },
    { img: CommuDetail, imgDescrip: "글 상세 페이지" },
    { img: LecturePage, imgDescrip: "강의목록 페이지" },
    { img: PaymentedPage, imgDescrip: "결제완료 페이지" },
    { img: MyPageDashBoard, imgDescrip: "마이페이지 대시보드" },
  ],
  deploy: null,
  github: "github.com/sunghyun-biblee/ClassHub",
  category: "팀 프로젝트",
};
